#include <vector>
#include <iostream>
#include <string>
#include <fstream>
#include <memory>
#include <list>
#include <utility>
#include <limits>
#include <algorithm>



namespace bstar{

struct BNode {
  int id;
  size_t width;
  size_t height;
  size_t llx = 0;
  size_t lly = 0;
  std::shared_ptr<BNode> parent{ nullptr };
  std::shared_ptr<BNode> left{ nullptr };
  std::shared_ptr<BNode> right{ nullptr };  
};



class BStar {
  friend class BStarTester;

  public:
    BStar();
    //void simulated_annealing();
    void optimize();
    void open(const std::string input_file);
    void dump(std::ostream& os) const;
    void dump_json(std::string output_file) const;

  private:
    std::vector<std::shared_ptr<BNode>> _modules;
    
    // _contour stores modules which define the contour
    std::vector<std::shared_ptr<BNode>> _contour;

    std::shared_ptr<BNode> _root;
    
    std::map<int, int> _mapping_id_index;

    void _generate_initial_tree();
    void _pack(std::shared_ptr<BNode> node);
    void _update_contour_after_insertion(
      const std::shared_ptr<BNode> node);
    
    size_t BStar::_calculate_coordinate(const std::shared_ptr<BNode> node);
};


BStar::BStar() {
  std::cout << "bstar constructor\n";
}


// read in the module configurations
void BStar::open(const std::string input_file) {
  std::ifstream infile(input_file);
  std::cout << "bstar open\n";
   
  if (!infile) {
    std::cerr << "File could not be opened!!\n";
    std::exit(EXIT_FAILURE);
  }

  size_t num_modules, width, height, id, index = 0;
  infile >> num_modules;

  while (infile >> id >> width >> height) {
    std::shared_ptr<BNode> node = std::make_shared<BNode>();
    node->id = id;
    node->width = width;
    node->height = height; 

    _modules.push_back(node);

    _mapping_id_index[index] = id;
    ++index;

  }
  std::cout << "successfully open circuit\n";
}


// dump floorplan to console
void BStar::dump(std::ostream& os) const {
  for (size_t i = 0; i < _modules.size(); ++i) {
    os << _modules[i]->id << ' '
       << _modules[i]->llx << ' '
       << _modules[i]->lly << ' '
       << _modules[i]->width << ' '
       << _modules[i]->height << ' ';
    
    if (_modules[i]->parent)
      os << " ,parent = " << _modules[i]->parent->id << ' ';

    if (_modules[i]->left)
      os << " ,left = " << _modules[i]->left->id << ' ';

    if (_modules[i]->right)
      os << " ,right = " << _modules[i]->right->id << ' ';
    
    os << '\n';
  }
}


// dump floorplan to a file with a json extesion
// not yet finished
void BStar::dump_json(std::string output_file) const {
  if(output_file.rfind(".json") == std::string::npos)
    output_file.append(".json");
  
  std::ofstream outfile(output_file, std::ios::out);
 
  if(!outfile) {
    std::cerr << "File could not be opened for writing\n";
    std::exit(EXIT_FAILURE); 
  } 
}


// generate an initial ordered binary 
void BStar::_generate_initial_tree() {
  for (size_t i = 0; i < _modules.size(); ++i) {
    if (i*2+1 < _modules.size()) {
      _modules[i]->left = _modules[i*2+1].get();
      _modules[i*2+1]->parent = _modules[i].get();
    }

    if (i*2+2 < _modules.size()) {
      _modules[i]->right = _modules[i*2+2].get();
      _modules[i*2+2]->parent = _modules[i].get();
    }     
  }

  _root = _modules[0].get();  
}


// update contour
void BStar::_update_contour_after_insertion(
  const std::shared_ptr<BNode> node) {

  if (_contour.empty()) {
    _contour.push_back(node);
    return;
  }

  if (node->parent) { 
    auto index = std::find(_contour.begin(), 
                           _contour.end(), 
                           node->parent);
    auto l_idx = index;
    auto r_idx = index;
       
    while (index != _contour.end()) {
      if ((node->llx + node->width) >= 
          (node->parent->llx + node->parent->width)) {
        ++index;        
      }
      else{
        r_idx = index;
        break;
      }
    }

    l_idx = _contour.insert(l_idx, node);
    _contour.erase(l_idx+1, r_idx);
  } 
    
  else {
    _contour.push_back(node);
    return; 
  }
}


// calculate the low left coordinate of the node
size_t BStar::_calculate_coordinate(std::shared_ptr<BNode> node) {
  size_t coordinate;

  if (node->parent) {
    auto index = std::find(_contour.begin(), 
                           _contour.end(), 
                           node->parent->id);
    
    while (index != _contour.end()) {
      if (_modules[_mapping_id_index[*index]])  
    }
  }

  return coordinate;
}


// pack the modules
void BStar::_pack(std::shared_ptr<BNode> node) {
  if (node == _root)
    _update_contour_after_insertion(node);
    
  if (node->left) {
    node->left->llx = node->llx + node->width;
    node->left->lly = _calculate_coordinate(node->left); 
    _update_contour_after_insertion(node->left);

    _pack(node->left);
  }

  if (node->right) {
    node->right->llx = _calculate_coordinate(node->right);
    node->right->lly = node->lly + node->height;
    _update_contour_after_insertion(node->right);
    
    _pack(node->right); 
  }
}


// optimize the floor plan
void BStar::optimize() {
  _generate_initial_tree();

  _pack(_root);
}

}
